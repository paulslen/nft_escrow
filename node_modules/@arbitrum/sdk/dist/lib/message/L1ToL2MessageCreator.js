"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ToL2MessageCreator = void 0;
const L1ToL2MessageGasEstimator_1 = require("./L1ToL2MessageGasEstimator");
const L1Transaction_1 = require("./L1Transaction");
const Inbox__factory_1 = require("../abi/factories/Inbox__factory");
const networks_1 = require("../dataEntities/networks");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const errors_1 = require("../dataEntities/errors");
const lib_1 = require("../utils/lib");
/**
 * Creates retryable tickets by directly calling the Inbox contract on L1
 */
class L1ToL2MessageCreator {
    constructor(l1Signer) {
        this.l1Signer = l1Signer;
        if (!signerOrProvider_1.SignerProviderUtils.signerHasProvider(l1Signer)) {
            throw new errors_1.MissingProviderArbTsError('l1Signer');
        }
    }
    /**
     * Creates a retryable ticket by directly calling the Inbox contract on L1
     */
    async createRetryableTicket(l2Provider, l2CallTo, l2CallData, l2CallValue, options, gasParams, overrides = {}) {
        const sender = await this.l1Signer.getAddress();
        const excessFeeRefundAddress = (options === null || options === void 0 ? void 0 : options.excessFeeRefundAddress) || sender;
        const callValueRefundAddress = (options === null || options === void 0 ? void 0 : options.callValueRefundAddress) || sender;
        const l1Provider = signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(this.l1Signer);
        const defaultedGasParams = gasParams ||
            (await (async () => {
                const gasEstimator = new L1ToL2MessageGasEstimator_1.L1ToL2MessageGasEstimator(l2Provider);
                const baseFee = await (0, lib_1.getBaseFee)(signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(this.l1Signer));
                return await gasEstimator.estimateAll(sender, l2CallTo, l2CallData, l2CallValue, baseFee, excessFeeRefundAddress, callValueRefundAddress, l1Provider);
            })());
        const l2Network = await (0, networks_1.getL2Network)(l2Provider);
        const inbox = Inbox__factory_1.Inbox__factory.connect(l2Network.ethBridge.inbox, this.l1Signer);
        const res = await inbox.createRetryableTicket(l2CallTo, l2CallValue, defaultedGasParams.maxSubmissionFee, excessFeeRefundAddress, callValueRefundAddress, defaultedGasParams.gasLimit, defaultedGasParams.maxFeePerGas, l2CallData, Object.assign({ value: defaultedGasParams.totalL2GasCosts.add(l2CallValue) }, overrides));
        const receipt = await res.wait();
        return new L1Transaction_1.L1TransactionReceipt(receipt);
    }
}
exports.L1ToL2MessageCreator = L1ToL2MessageCreator;
